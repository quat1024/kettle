<!DOCTYPE html>
<html><head><script id="bootstrap" type="text/javascript">//TODO: Bad data structure.

let cardsArray = [];

function getCard(id) {
  for(const card of cardsArray) {
    if(card.id === id) return card;
  }
  return undefined;
}

function updateOrAddCard(card) {
  for(let i = 0; i < cardsArray.length; i++) {
    if(cardsArray[i].id === card.id) {
      cardsArray[i] = card;
      return;
    }
  }
  cardsArray.push(card);
}

function deleteCardWithId(id) {
  for(let i = 0; i < cardsArray.length; i++) {
    if(cardsArray[i].id === id) {
      cardsArray.splice(i, 1);
      return;
    }
  }
}

function callCard(id, ...args) {
  return cardCallable(id)(...args);
}

function cardCallable(id) {
  //todo: janky, will need to check this is the right scope, and stuff
  const card = getCard(id);
  return eval(`(${card["args"]}) => { ${card["text"]} }`);
}

class KettleCard extends HTMLElement {}
customElements.define("kettle-card", KettleCard);

class KettleProp extends HTMLElement {}
customElements.define("kettle-prop", KettleProp);

function cardToHtml(card) {
  const kvs = [];
  for(const prop in card) {
    if(prop === "id") continue;
    kvs.push("\n  ");
    kvs.push(h("kettle-prop", {"data-prop": prop}, card[prop]));
  }
  kvs.push("\n");
  const htm = h("kettle-card", {id: card.id}, kvs);
  return htm;
}

function htmlToCard(html) {
  const card = {};
  card.id = html.id;
  for(const child of Array.from(html.children)) {
    if(child instanceof KettleProp) {
      card[child.dataset.prop] = child.innerText;
    }
  }
  return card;
}

function makeCardViewer(card) {
  const htm = h("div", {},
    h("h2", {innerText: card.id}),
    card["args"] ? h("p", {}, "args: ", card["args"]) : [],
    card["text"] ? h("p", {}, "text: ", h("pre", {}, card["text"])) : [],
    h("button", {className: "edit"}, "Edit"),
    h("button", {className: "run"}, "Call (no args)"),
  );
  
  htm.querySelector(".edit").addEventListener("click", () => {
    const editor = makeCardEditor(card);
    htm.insertAdjacentElement("beforebegin", editor);
    htm.remove();
  });

  htm.querySelector(".run").addEventListener("click", () => {
    callCard(card.id);
  });
  
  return htm;
}

function makeCardEditor(card) {
  const oldId = card.id;

  const htm = h("div", {},
    h("input", {className: "id", type: "text", value: card.id}),
    h("br"),
    h("input", {className: "args", type: "text", value: card.args ? card.args : ""}),
    h("br"),
    h("textarea", {rows: 15, cols: 80, spellcheck: "false"}, card["text"]),
    h("button", {className: "save"}, "Save"),
    h("button", {className: "delete"}, "Delete")
  );

  const idField = htm.querySelector(".id");
  const argsField = htm.querySelector(".args");
  const textField = htm.querySelector("textarea");

  htm.querySelector(".save").addEventListener("click", () => {
    const newCard = {
      id: idField.value,
      args: argsField.value,
      text: textField.value
    };
    deleteCardWithId(oldId);
    updateOrAddCard(newCard);
    
    const viewer = makeCardViewer(newCard);
    htm.insertAdjacentElement("beforebegin", viewer);
    htm.remove();
  });
  
  htm.querySelector(".delete").addEventListener("click", () => {
    if(confirm(`Are you sure you want to delete ${oldId}?`)) {
      deleteCardWithId(oldId);
      htm.remove();
    }
  });
  
  return htm;
}

function makeNewCard() {
  let newName = "NewCard";
  if(getCard(newName)) {
    let disambig = 1;
    do {
      newName = `NewCard${disambig}`;
      disambig++;
    } while(getCard(newName) && disambig <= 100);
    if(disambig == 100) {
      console.log("Can't make new card");
      return;
    }
  }
  
  const card = {id: newName, args: "", text: ""};
  updateOrAddCard(card);

  const editor = makeCardEditor(card);
  document.getElementById("cards").insertAdjacentElement("beforeend", editor);
}

function recursiveAssign(target, src) {
  for(const key in src) {
    if(typeof src[key] == "object") {
      target[key] = target[key] || {};
      recursiveAssign(target[key], src[key]);
    } else target[key] = src[key];
  }
}

function h(elem, attrs, ...children) {
  attrs = attrs || {};

  let e = document.createElement(elem);
  recursiveAssign(e, attrs);
  for(const key of Object.keys(attrs)) {
    if(key.startsWith("data-")) {
      e.dataset[key.slice(5)] = attrs[key];
    }
  }
  children.flat(Infinity).forEach(child => {
    if(child instanceof HTMLElement) e.appendChild(child);
    else e.appendChild(document.createTextNode(child));
  });
  return e;
}

function quine() {
  const htm = h("html", {}, 
    h("head", {},
      h("script", {id: "bootstrap", type: "text/javascript"},
        getCard("bootstrap").text
      )
    ),
    h("body", {},
      //Cheap hack to prevent card elements from showing thru
      h("div", {style: { display: "none" }},
        cardsArray
          //The bootstrap card is stored as a script, not a custom html element
          .filter(card => card.id != "bootstrap")
          .map(card => cardToHtml(card))
      )
    )
  );
  return "<!DOCTYPE html>\n" + htm.outerHTML;
}

function doSave() {
  let url = window.URL.createObjectURL(new Blob([quine()]));
  let a = h("a", {href: url, download: "kettle.html"});
  a.click();
  window.URL.revokeObjectURL(url);
}

function doIframe() {
  let bag = h("div", {},
    h("br"),
    h("iframe", {style: {width: "95vw", height: "95vh"}, srcdoc: quine()}),
    h("button", {}, "Close")
  );
  
  bag.querySelector("button").addEventListener("click", () => {
    if(confirm("Are you sure?")) bag.remove();
  });
  document.body.appendChild(bag);
}

function ready() {
  //read all cards except for me
  Array.from(document.querySelectorAll("kettle-card"))
    .map(htm => htmlToCard(htm))
    .forEach(card => updateOrAddCard(card));
  
  //add myself to the list of cards
  updateOrAddCard({
    id: "bootstrap",
    args: "",
    text: document.getElementById("bootstrap").innerText
  });

  //write out card editors
  let cardContainer = h("div", {id: "cards"}, cardsArray.map(card => makeCardViewer(card)));
  document.body.insertAdjacentElement("beforeend", cardContainer);
  
  //add quine buttons
  const saveButton = h("button", {}, "Save Html");
  saveButton.addEventListener("click", doSave);
  document.body.insertAdjacentElement("afterbegin", saveButton);

  const iframeButton = h("button", {}, "Iframe");
  iframeButton.addEventListener("click", () => callCard("doIframe"));
  saveButton.insertAdjacentElement("afterend", iframeButton);

  //new card button
  const newButton = h("button", {}, "New Card");
  newButton.addEventListener("click", makeNewCard);
  document.body.insertAdjacentElement("beforeend", newButton);
}
document.addEventListener("DOMContentLoaded", ready);</script></head><body><div style="display: none;"><kettle-card id="logQuine">
  <kettle-prop data-prop="args"></kettle-prop>
  <kettle-prop data-prop="text">console.log(callCard("quine"));</kettle-prop>
</kettle-card><kettle-card id="quine">
  <kettle-prop data-prop="args"></kettle-prop>
  <kettle-prop data-prop="text">const htm = h("html", {}, 
  h("head", {},
    h("script", {id: "bootstrap", type: "text/javascript"},
      getCard("bootstrap").text
    )
  ),
  h("body", {},
    //Cheap hack to prevent card elements from showing thru
    h("div", {style: { display: "none" }},
      cardsArray
        //The bootstrap card is stored as a script, not a custom html element
        .filter(card =&gt; card.id != "bootstrap")
        .map(card =&gt; cardToHtml(card))
    )
  )
);
return "&lt;!DOCTYPE html&gt;\n" + htm.outerHTML;</kettle-prop>
</kettle-card><kettle-card id="doIframe">
  <kettle-prop data-prop="args"></kettle-prop>
  <kettle-prop data-prop="text">let quine = cardCallable("quine");

console.log("calling code from a card !!");

let bag = h("div", {},
  h("br"),
  h("iframe", {style: {width: "95vw", height: "95vh"}, srcdoc: quine()}),
  h("button", {}, "Close")
);

bag.querySelector("button").addEventListener("click", () =&gt; {
  if(confirm("Are you sure?")) bag.remove();
});
document.body.appendChild(bag);</kettle-prop>
</kettle-card></div></body></html>